#include "polymer_class.h"
#include "math_functions.h"
#include "polymer_generation.h"

//sample a random base.
std::string polymer::random_base() {
    int rn = rand() % 4;
    std::string base[4] = { "C","U","A","G" };

    return base[rn];
}


//polymer constructors
//**************************************************************************************//
//**************************************************************************************//
//**************************************************************************************//
polymer::polymer(int num) {
    N = num;//set number of monomers in polymer

    std::vector<monomer*> M(N);
    for (int i{ 0 }; i < N; i++) {
        M[i] = new monomer();//add monomers with uninitialized position to the vector of monomers which 
        //defines a polymer (is a member variable of class polymer)
    }
    chain = M;
}

//another constructor where we only have 2 monomers. Not used so could remove. 
polymer::polymer(std::vector<double> beginning_position, std::vector<double> end_position) {
    N = 2;
    chain.push_back(new monomer(beginning_position, 0, "U"));
    chain.push_back(new monomer(end_position, 1, "G"));
}

//MOST USED constructor. Takes vector of positions generated by polymer_generation functions as arg.
polymer::polymer(std::vector<std::vector<double>> generated_positions)
{
    std::vector<monomer*> M(generated_positions.size());
    for (int i{ 0 }; i < generated_positions.size(); i++) {
        M[i] = new monomer(generated_positions[i], i, random_base());//add monomers to vector of monomer objects
        //which define polymer object.
        std::cout << M[i]->get_base() << " ";
    }
    std::cout << std::endl;
    chain = M;
}
//**************************************************************************************//
//**************************************************************************************//
//**************************************************************************************//


//general functions of the polymer and given monomer in the chain. uses monomer class functions.
int polymer::chain_length() {
    return chain.size();
}

void polymer::get_monomer_position(int id) {
    chain[id]->get_position();
}

void polymer::add_monomer(std::vector<double> position, std::string base_type) {
    auto iterator = chain.end() - 1;
    chain[chain.size() - 1]->id++;
    chain.insert(iterator, new monomer(position, chain.size() - 1, base_type));

    N++;
}

//useful if we want to print positions
std::vector<std::vector<double>> polymer::generate_vector_of_monomer_positions()
{
    std::vector<std::vector<double>> temp;
    for (int i{ 0 }; i < chain.size(); i++) {
        temp.push_back(chain[i]->get_position());
    }

    return temp;
}
void polymer::print_monomer_positions()
{
    for (int i{ 0 }; i < chain.size(); i++) {
        std::cout << i << " ";

        std::cout << "{ ";

        for (int j{ 0 }; j < 3; j++) {
            std::cout << generate_vector_of_monomer_positions()[i][j] << " ";
        }
        std::cout << "}" << std::endl;
    }
}

//format output to view polymer in ovito. Give different colours to interesting monomers (start and endpoints
// or helixes or...)
void polymer::output_for_ovito() {

    std::string file_name{ "polymer " + std::to_string(rand2(0,1)) + ".txt" };
    std::ofstream ovito_output(file_name);
    std::vector<std::vector<double>> polymer{ generate_vector_of_monomer_positions() };
    ovito_output << polymer.size() << "\n\n";
    for (int i{ 0 }; i < polymer.size(); i++) {
        std::string line{ "" };
        if (i % 2 == 0) {
            line += "C";
        }
        else if (i % 2 != 0) {
            line += "O";
        }
        for (int j{ 0 }; j < polymer[i].size(); j++) {
            line += " " + std::to_string(polymer[i][j]);
        }
        if (i == polymer.size() - 1) {
            //std::cout << "this line ran";
            ovito_output << line << std::endl;;
        }
        else {
            ovito_output << line << "\n";
        }
    }

    ovito_output.close();
}

//overload operator [] to easily refer to monomers in polymer.
monomer* polymer::operator[](int i) {
    return chain[i];
}
//**************************************************************************************//
//**************************************************************************************//
//**************************************************************************************//
//**************************************************************************************//
//**************************************************************************************//
//**************************************************************************************//

//polymer functions focussed around finding stuctures ie compatible regions taking into account
// 3' and 5' directionality.
bool polymer::compatible_bases(monomer* monomer_i, monomer* monomer_j) {
    if (monomer_i->get_base() == "U" && monomer_j->get_base() == "A" || monomer_i->get_base() == "A" && monomer_j->get_base() == "U") { return true; }
    else if (monomer_i->get_base() == "G" && monomer_j->get_base() == "C" || monomer_i->get_base() == "C" && monomer_j->get_base() == "G") { return true; }
    else { return false; }
}


bool polymer::base_pairing_rules(char b1, char b2)
{
    if (b1 == 'A' && b2 == 'U') {
        return true;
    }
    else if (b1 == 'U' && b2 == 'A') {
        return true;
    }
    else if (b1 == 'C' && b2 == 'G') {
        return true;
    }
    else if (b1 == 'G' && b2 == 'C') {
        return true;
    }
    else return false;
}

// return bool if regions are compatible.
bool polymer::regions_compatible(std::string r1, std::string r2)
{
    int counter{ 0 };
    for (int i{ 0 }; i < r1.length(); i++) {
        //this is where directionality in the search is implemented.
        base_pairing_rules(r1.at(i), r2.at(r1.length() - i-1)) ? counter++ : counter = 0;
    }
    if (counter == r1.size()) {
        return true;
    }
    else {
        return false;

    }
}

std::vector<int> polymer::position_of_region(int i, int r)
{
    std::vector<int> reg;
    for (int j{ 0 }; j < r; j++) {
        reg.push_back(i + j);
    }
    return reg;
}

//**************************************************************************************////**************************************************************************************//
//**************************************************************************************////**************************************************************************************//
//**************************************************************************************////**************************************************************************************//
//function which finds all the potential structures of arbitrary size which could be formed 
std::vector<std::vector<std::vector<int>>> polymer::structure_search()
{
    int r_max{ static_cast<int>(std::floor(chain.size() / 2))};//if you have 50 bases in the strand, you cannot find compatible regions of more than 50/2.

    //our goal is to store all the compatible regions for each r in the same vector. the compatible regions for a given r form a 2d vector.
    //so we need a vector of 2d vectors ie a 3d vector, "potential_structures" declared below.
    std::vector < std::vector < std::vector<int>>> potential_structures;

    //we initialize each monomer with a random base. the lines below add all the bases to 
    std::vector<std::string> bases(chain.size());
    for (int b{ 0 }; b < chain.size(); b++) {
        bases[b]=chain[b]->get_base();
    }

    for (int r{ 2 }; r <= r_max; r++) {//loop through all the possible group sizes r. we don't consider regions of 2.
        std::vector<std::string> regions_r;

        for (int i{ 0 }; i < bases.size()-1; i++) {
            if (chain.size() - i <= r - 1) {//when we get towards the end of the chain, e.g r=2 for U A G C, once we get to C we cannot form a group of 2 so break.
                break;
            }
            else {
                std::string region{ "" };
                for (int j{ 0 }; j < r; j++) {
                    
                    region += bases[i + j];

                }
                regions_r.push_back(region);

            }
        }
        std::vector<std::vector<int>> search_results_r;//we store the compatible regions for a given group size r.

        for (int k{ 0 }; k < regions_r.size()-1; k++) {//loop through regions. k is the region we compare all the others to(l).
            for (int l{ r}; l < regions_r.size(); l++) {
                //we don't need to compare compatibility for regions l which share bases with region k.
                //so we can skip that part of the loop with the continue statement.
                if (abs(l-k) < r||l<k) {
                    continue;
                }

                //here we save the corresponding position (integer order in the chain, not euclidian position) of compatible bases
                if (regions_compatible(regions_r[k], regions_r[l])) {
                    std::vector<int> format_result;
                    for (int c{ 0 }; c < r; c++) {
                        format_result.push_back(position_of_region(k,r)[c]);
                    }
                    for (int c{ 0 }; c < r; c++) {
                        format_result.push_back(position_of_region(l,r)[c]);
                    }
                    search_results_r.push_back(format_result);
                }
            }
        }
        if (search_results_r.size() == 0) {
            //if there are no compatible regions for groups of size (r-1) then there can be no compatible regions for r.
            //so we save time by breaking the search at that point.
            break;
        }
        //print results of search
        if (search_results_r.size() > 0) {
            std::cout << "Results for region of length " << r << std::endl;
            for (auto v : search_results_r) {
                for (auto e : v) {
                    std::cout << e << " ";
                }std::cout << std::endl;
            }std::cout << std::endl;

        }
        potential_structures.push_back(search_results_r);


    }
    return potential_structures;
}

//pick a random structure out of the list of potential structures.
std::vector<int> polymer::sample_structure(std::vector<std::vector<std::vector<int>>> potential_structures)
{
    int r{ static_cast<int>(rand2(0,potential_structures.size())) };
    int k{ static_cast<int>(rand2(0,potential_structures[r].size())) };

    std::cout << "sampled structure is " << std::endl;
    for (auto i : potential_structures[r][k]) {
        std::cout << i << " ";
    }std::cout << std::endl;

    return potential_structures[r][k];
}

//**************************************************************************************////**************************************************************************************//
//**************************************************************************************////**************************************************************************************//
//**************************************************************************************////**************************************************************************************//

//the following section deals with generating a helix once we have picked two compatible regions which we link.

//parameters of the helix: 

//major groove
//const double Mg = 0.47;
const double Mg = 100 * (0.47 / 1.08);

//minor groove
//const double mg = 1.08;
const double mg = 100;

//diameter
//const double dm = 2.5;
const double dm = 100;

double the = acos((2 * dm * dm / 4 - mg * mg) / (2 * dm * dm / 4.));

//v: helix direction
//x : euclidean position of the starting base pair backbone
//u : versor joining the center of the helix to x; uand v are orthogonal

//adapted from the Python notebook generate_helix that I was given. 
// 
//rotate u around v of theta
std::vector<double> polymer::rotate_helix(std::vector<double> u, std::vector<double> v, double the) {
    double cthe = cos(the);
    double sthe = sin(the);
    double v_dot_u = dot_product(u, v);
    //v_vec_u = np.zeros(3)
    std::vector<double> v_vec_u;

    v_vec_u.push_back(v[1] * u[2] - v[2] * u[1]);
    v_vec_u.push_back(v[2] * u[0] - v[0] * u[2]);
    v_vec_u.push_back(v[0] * u[1] - v[1] * u[0]);

    std::cout << std::endl;
    std::vector<double> wx;
    wx = multiplication_by_scalar(cthe, u);
    wx = vector_addition(wx, multiplication_by_scalar(sthe, v_vec_u));
    wx = vector_addition(wx, multiplication_by_scalar((1.0 - cthe) * v_dot_u, v));


    return wx;

}

//generate an A - RNA helix of n bp
void polymer::generate(std::vector<int> compatible_monomers,std::vector<double> v, std::vector<double> u, std::vector<double> x) {
    
    size_t n{ compatible_monomers.size() / 2 };
    
    std::vector<std::vector<double>> strand_x(n);
    std::vector<std::vector<double>> strand_y(n);
    double theta = 0.75 * atan(1) * 4;
    double phi = 33 * (atan(1) * 4) / 180;
    double radius{ 1 };

    std::vector<double> running_centre{ vector_subtraction(x,multiplication_by_scalar(radius,u)) };

    std::vector<double> w{ rotate_helix(u,v,theta) };

    std::vector<double> y = vector_addition(running_centre, multiplication_by_scalar(radius, w));

    strand_x[0] = x;
    strand_y[n - 1] = y;

    int running_n{ 1 };
    while (running_n < n) {
        running_centre = vector_addition(running_centre, multiplication_by_scalar(0.9, v));
        //running_centre = vector_addition(running_centre, multiplication_by_scalar(0.28, v));
        std::vector<double> up = rotate_helix(u, v, phi);

        std::vector<double> wp = rotate_helix(w, v, phi);

        u = up;

        w = wp;
        std::vector<double> running_x{ vector_addition(running_centre,multiplication_by_scalar(radius,u)) };

        std::vector<double> running_y{ vector_addition(running_centre,multiplication_by_scalar(radius,w)) };

        strand_x[running_n] = running_x;
        strand_y[n - running_n - 1] = running_y;
        running_n++;

    }
    //store the newly generated positions of the monomers in the helix in the polymer object.
    for (int j{ 0 }; j < compatible_monomers.size() / 2; j++) {
        chain[compatible_monomers[j]]->change_position(strand_x[j]);
    }
    for (int k{ 0 }; k < compatible_monomers.size() / 2; k++) {
        chain[compatible_monomers[k+ compatible_monomers.size()/2]]->change_position(strand_y[k]);
    }


}


// for later when link move is made...
void polymer::classify_compatible_regions(std::vector<std::vector<int>> search_results)
{
    for (int i = 0; i < search_results.size(); i++) {
        std::vector<int> monomers_in_region{ search_results[i] };
        //std::cout << "{";
        //std::cout << "Region of length: " << search_results[i].size() << std::endl;
        std::cout << "{";
        //std::cout << "Region of length: " << search_results[i].size() << std::endl;

        for (int j = 0; j < search_results[i].size(); j++)
        {
            std::cout << search_results[i][j] << " ";
        }

        std::cout << "}\n";

        if (monomers_in_region[0] == 0 || monomers_in_region.back() == chain_length() - 1) {
            std::cout << "Case 1" << std::endl;
        }
        else if (monomers_in_region[0] == 0 && monomers_in_region.back() == chain_length() - 1) {
            std::cout << "Case 3" << std::endl;
        }
        else {
            std::cout << "Case 2" << std::endl;
        }

    }

}

//void polymer::link_move()
//{
//    //pick a compatible region pair to link
//    std::vector<std::vector<int>> reactive_regions{ structure_search() };
//    int rand_reactive_region = rand() % reactive_regions.size();
//    int n = rand_reactive_region;
//    std::vector<int> monomers_in_region{ reactive_regions[n] };
//
//    for (auto i : monomers_in_region) {
//        std::cout << i << " ";
//    }
//    
//    //classification of situation
//    if (monomers_in_region[0] == 0 || monomers_in_region.back() == chain_length() - 1) {
//        std::cout << "Case 1" << std::endl;
//
//        //find connected part
//        size_t side_num{ monomers_in_region.size() / 2 };
//        size_t helix_num{ monomers_in_region.size() };
//
//
//        int enclosed_num{ monomers_in_region[helix_num / 2] - monomers_in_region[helix_num / 2 - 1] };
//        std::cout << "number of enclosed segments " << enclosed_num << std::endl;
//        std::cout << "monomers to be regrown: ";
//        for (int j{ 1 }; j <= enclosed_num; j++) {
//
//            std::cout << monomers_in_region[side_num - 1] + j << std::endl;
//        }
//
//    }
//    else if (monomers_in_region[0] == 0 && monomers_in_region.back() == chain_length() - 1) {
//        std::cout << "Case 3" << std::endl;
//    }
//    else {
//        std::cout << "Case 2" << std::endl;
//
//        //find connected part
//        size_t side_num{ monomers_in_region.size() / 2 };
//        size_t helix_num{ monomers_in_region.size() };
//
//
//        int enclosed_segm{ monomers_in_region[helix_num - side_num] - monomers_in_region[side_num-1] };
//        std::cout << "number of enclosed monomers " << enclosed_segm << std::endl;
//
//        if (enclosed_segm > 2){
//            //std::cout << "monomers to be regrown: ";
//            std::vector<int> enclosed_region;
//            enclosed_region.push_back(monomers_in_region[side_num - 1]);
//            //enclosed_region.push_back(monomers_in_region[helix_num - 1]);
//            for (int j{ 1 }; j <= enclosed_segm; j++) {
//                enclosed_region.push_back(monomers_in_region[side_num - 1] + j);
//                //std::cout << monomers_in_region[side_num-1] +j<< std::endl;
//            }
//            //for (auto m : enclosed_region) {
//            //    std::cout << m << std::endl;
//            //}
//
//        }
//
//        //find dangling regions
//        std::vector<int> dangle1;
//        std::vector<int> dangle2;
//
//        std::cout << "dangle 1 " << std::endl;
//        for (int k{ 0 }; k <= monomers_in_region[0]; k++) {
//            //std::cout << k << std::endl;
//            dangle1.push_back(k);
//        }
//        //dangle1.push_back(monomers)
//        std::cout << "dangle 2 " << std::endl;
//
//        for (int k{ 0 }; k <= chain_length()-monomers_in_region.back(); k++) {
//            //std::cout << monomers_in_region.back() + k << std::endl;
//            dangle2.push_back(monomers_in_region.back()+k);
//        }
//
//        //helix growth
//        //sample helix vectors
//        std::vector <double> u{ sample_jump_direction(1) }, v{ sample_jump_direction(1) };
// 
//        //sample starting base (do it later)
//        std::vector<double> helix_origin{ chain[monomers_in_region[0]]->get_position() };
//         
//        //print_monomer_positions();
//        generate(monomers_in_region, v, u, helix_origin);
//        print_monomer_positions();
//
//        ////connected region regrowth
//        std::vector<double> start{ chain[monomers_in_region[helix_num - side_num-1]] ->get_position()};
//        //std::cout << "start position " << std::endl;
//        //for (auto p : start) {
//        //    std::cout << p << " ";
//        //}std::cout << std::endl;
//        std::vector<double> end{ chain[monomers_in_region[helix_num-side_num]]->get_position() };
//        //std::cout << "end position " << std::endl;
//
//        //for (auto p : end) {
//        //    std::cout << p << " ";
//        //}
//        std::cout << "Enclosed segments " << enclosed_segm << std::endl;
//        std::vector<std::vector<double>> connected_part{ grow_chain(start,end,enclosed_segm) };
//        for (int j{ 1 }; j < enclosed_segm; j++) {
//            chain[monomers_in_region[helix_num - side_num - 1]+j]->change_position(connected_part[j]);
//        }
//
//        std::cout << "Dangle 1 segments to regrow " << dangle1.size() -1<< std::endl;
//        for (auto e : dangle1) {
//            std::cout << e << " ";
//        }std::cout << std::endl;
//
//        ////dangling regions
//        // 
//        //dangling region 1
//        std::vector<double> start1{ chain[0]->get_position() };
//        std::vector<double> end1{ chain[monomers_in_region[0]]->get_position() };
//        std::vector<std::vector<double>> dangling1{ grow_chain(start1,end1,dangle1.size() - 1)};
//        std::cout << "Changing the positions of dangles (1)" << std::endl;
//        std::cout << "Monomers in region " << std::endl;
//        for (auto e : monomers_in_region) {
//            std::cout << e << " ";
//        }std::cout << std::endl;
//
//        for (int j{ 1 }; j < dangle1.size()-1; j++) {
//            chain[j]->change_position(dangling1[j]);
//        }
//
//        //dangling region 2
//        std::vector<double> start2{ chain[monomers_in_region.back()]->get_position()};
//        std::vector<double> end2{chain.back()->get_position()};
//        std::cout << "printing dangle 2 " << std::endl;
//        for (auto e : dangle2) {
//            std::cout << e << " ";
//        }std::cout << std::endl;
//        //print_monomer_positions();
//        std::vector<std::vector<double>> dangling2{ grow_chain(start2,end2,dangle2.size() - 2) };
//        std::cout << "segments to be regrown " << dangle2.size() - 1 << std::endl;
//        std::cout << "Changing the positions of dangles (2)" << std::endl;
//        std::cout << "Monomers in region " << std::endl;
//        for (auto e : monomers_in_region) {
//            std::cout << e << " ";
//        }std::cout << std::endl;
//        print_monomer_positions();
//        for (int j{ 1 }; j < dangle2.size() - 1; j++) {
//            chain[monomers_in_region.back()+j]->change_position(dangling2[j]);
//        }
//        print_monomer_positions();
//
//        output_for_ovito();
//
//    }
//
//    //helix growth
//
//    //dangling regions growth
//}

